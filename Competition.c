#pragma config(Sensor, in1,    pot,            sensorPotentiometer)
#pragma config(Motor,  port2,           frontRight,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           backRight,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           frontLeft,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           backLeft,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           Motor6,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           Motor7,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           Motor8,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           Motor9,        tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// This function is invoked when the robot enters Autonomous.
// This is either during competition or if you press 7U and 8U at once.
void autonomous() {
	// REPLACE THIS WITH AUTONOMOUS
	wait1Msec(1000);
}

int threshold = 15;

// This function is invoked in a loop to perform driver control.
void joystick() {
	// Mecanum style, with a threshold. The threshold avoids having
  // a joystick that is too sensitive throw off the direction of
  // robot.
  // http://www.robotc.net/blog/2011/11/22/vex-mecanum-drive-using-robotc/
  int X2 = 0, Y1 = 0, X1 = 0;

  if(abs(vexRT[Ch3]) > threshold) Y1 = vexRT[Ch3];
  if(abs(vexRT[Ch4]) > threshold) X1 = vexRT[Ch4];
  if(abs(vexRT[Ch1]) > threshold) X2 = vexRT[Ch1];

  //Remote Control Commands
  motor[frontRight] = Y1 - X2 - X1;
  motor[backRight] =  Y1 - X2 + X1;
  motor[frontLeft] =  Y1 + X2 + X1;
  motor[backLeft] =   Y1 + X2 - X1;
}

// ==========================================================================
// ========= Things below this line don't need to be modified ===============
// ==========================================================================

  //                             ,|
  //                           //|                              ,|
  //                         //,/                             -~ |
  //                       // / |                         _-~   /  ,
  //                     /'/ / /                       _-~   _/_-~ |
  //                    ( ( / /'                   _ -~     _-~ ,/'
  //                     \~\/'/|             __--~~__--\ _-~  _/,
  //             ,,)))))));, \/~-_     __--~~  --~~  __/~  _-~ /
  //          __))))))))))))));,>/\   /        __--~~  \-~~ _-~
  //         -\(((((''''(((((((( >~\/     --~~   __--~' _-~ ~|
  //--==//////((''  .     `)))))), /     ___---~~  ~~\~~__--~
  //        ))| @    ;-.     (((((/           __--~~~'~~/
  //        ( `|    /  )      )))/      ~~~~~__\__---~~__--~~--_
  //           |   |   |       (/      ---~~~/__-----~~  ,;::'  \         ,
  //           o_);   ;        /      ----~~/           \,-~~~\  |       /|
  //                 ;        (      ---~~/         `:::|      |;|      < >
  //                |   _      `----~~~~'      /      `:|       \;\_____//
  //          ______/\/~    |                 /        /         ~------~
  //        /~;;.____/;;'  /          ___----(   `;;;/
  //       / //  _;______;'------~~~~~    |;;/\    /
  //      //  | |                        /  |  \;;,\
  //     (<_  | ;                      /',/-----'  _>
  //      \_| ||_                     //~;~~~~~~~~~
  //          `\_|                   (,~~
  //                                  \~\
  //                                   ~~


// True while autonomous is still running.
bool autonomous_on = false;

// Autonomous task. Invokes the user program and ensures
// |autonomous_on| is reset when the task is done.
task autonomous_task() {
	autonomous();
	autonomous_on = false;
}

// Continuously updates the display based on battery and mode.
task updateDisplay()
{
	char status[32];

	while (true) {
		if ((vexRT[Btn7U] && vexRT[Btn8U]) || bIfiAutonomousMode) {
			if (!autonomous_on) {
			  autonomous_on = true;
			  startTask(autonomous_task);
		  }
		}
		clearLCDLine(0);
    if (bIfiRobotDisabled) {
    	displayLCDCenteredString(0, "Dead Zeusette");
    } else {
    	displayLCDCenteredString(0, autonomous_on ? "Autozeusette!" : "Superzeusette!");
    }
	  clearLCDLine(1);
  	snprintf(status, sizeof(status)-1, "bat %d", nAvgBatteryLevel);
  	displayLCDCenteredString(1, status);
		wait1Msec(100);
	}
}

// Starts the display and enters optimistic user controlled.
task main()
{
	startTask(updateDisplay);

	// For competition, don't start too early.
	while (bIfiRobotDisabled) {
		wait1Msec(25);
	}

	while (true) {
		if (autonomous_on) {
			wait1Msec(25);
			continue;
		}
		joystick();
  }
}
